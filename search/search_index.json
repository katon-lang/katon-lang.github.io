{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p> A strict, statically typed prover language with SMT-backed state reasoning. </p> <p></p> <p>Katon is a proof-oriented verification language designed to answer a single question:</p> <p>Does this state-transforming computation satisfy its specification?</p> <p>Katon is not a general-purpose language; it is a proof-assistant designed to be smaller, stricter, and more principled than traditional verification tools.</p> <p>Katon exists to make reasoning about mutable state tractable, predictable, and fully automated.</p>"},{"location":"#what-makes-katon-different","title":"What Makes Katon Different","text":"<p>Katon is built around a small number of non-negotiable ideas:</p> <ul> <li> <p>Verification, not execution   Katon programs describe state transitions, not runtime behavior.</p> </li> <li> <p>Ownership eliminates aliasing   Rust-style move semantics remove aliasing at the language level,   dramatically simplifying reasoning.</p> </li> <li> <p>Automation over interaction   All proof obligations are discharged by SMT solvers.   There are no tactics, scripts, or interactive proofs.</p> </li> <li> <p>Small types, strong guarantees   A minimal type system keeps verification decidable and solver-friendly.</p> </li> </ul> <p>These constraints are not limitations. They are what make Katon precise.</p>"},{"location":"#a-glimpse-of-katon","title":"A Glimpse of Katon","text":"<p>A Katon <code>func</code> specifies how state may change and what must hold afterward:</p> <pre><code>func update(arr [int]) {\n    arr[0] = 99\n    ensures arr[0] == 99\n    ensures arr[1] == old(arr)[1]\n}\n</code></pre>"},{"location":"#what-katon-is-not","title":"What Katon Is Not","text":"<p>Katon intentionally excludes features that increase proof complexity:</p> <ul> <li> <p>no general recursion</p> </li> <li> <p>no heap allocation</p> </li> <li> <p>no higher-order functions</p> </li> <li> <p>no interactive proving</p> </li> </ul> <p>Every omission is deliberate. Every omission keeps reasoning simple.</p>"},{"location":"cli/","title":"CLI","text":"<p>When you install Katon, it also comes with the official CLI\u2014a powerful tool designed to manage the lifecycle of your Katon projects from initialization to verification.</p> <p>The Katon CLI allows you to:</p> <ol> <li> <p>Scaffold Katon projects: Quickly generate a standardized project structure.</p> </li> <li> <p>Verify Lemmas: Manually trigger formal verification of your logic, designed to be integrated into CI/CD pipelines.</p> </li> <li> <p>Transpile Code: Convert Katon source code into memory-safe Rust code (Experimental).</p> </li> </ol>"},{"location":"cli/#create-a-new-katon-project","title":"Create a New Katon Project","text":"<p>To start a new project, use the <code>new</code> command followed by your desired project name:</p> <p><pre><code>katon new myproject\n</code></pre> This command initializes a new directory named <code>myproject</code> with the following standardized boilerplate:</p>"},{"location":"cli/#project-structure","title":"Project Structure","text":"<ul> <li> <p><code>src/</code>: The core directory for your source code.</p> </li> <li> <p><code>src/myproject.ktn</code>: The entry point for your Katon project. This file is automatically named after your project and is where you begin defining your lemmas and logic.</p> </li> <li> <p><code>config.toml</code>: Contains project metadata, including the package name, version, and author information under the <code>[package]</code> header.</p> </li> <li> <p><code>.gitignore</code>: Pre-configured to ignore build artifacts and the <code>/target</code> directory to keep your repository clean.</p> </li> <li> <p><code>README.md</code>: A basic Markdown file generated with your project title, ready for your documentation.</p> </li> </ul> <p>VERIFY LEMMA &amp; TRANSPILATION COMING SOON!</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Katon is still in an early stage of development.</p> <p>If you are interested in formal verification, programming languages, or compiler construction\u2014or if you are working on a programming languages assignment\u2014you are welcome to try Katon and contribute.</p>"},{"location":"contributing/#ways-to-contribute","title":"Ways to Contribute","text":"<p>Contributions of all kinds are appreciated, including:</p> <ol> <li> <p>Bug reports: report incorrect behavior, crashes, or unsound verification results.</p> </li> <li> <p>Documentation improvements: clarify existing documentation, fix inaccuracies, or add missing language reference sections.</p> </li> <li> <p>Language and verifier development: work on the type system, semantics, verification condition generation, or SMT integration.</p> </li> <li> <p>Design discussions: propose or discuss language features, semantics, or design trade-offs.</p> </li> </ol>"},{"location":"contributing/#contribution-process","title":"Contribution Process","text":"<ol> <li> <p>Use GitHub Issues for bug reports, feature requests, and design discussions.</p> </li> <li> <p>Submit changes via pull requests.</p> </li> <li> <p>Small, focused pull requests are preferred.</p> </li> </ol> <p>For non-trivial changes, opening an issue for discussion first is recommended.</p>"},{"location":"contributing/#repository","title":"Repository","text":"<p>Katon on GitHub</p>"},{"location":"documentation/","title":"Overview","text":"<p>This section contains the technical documentation for the Katon language.</p> <p>It serves as the language reference, describing Katon\u2019s syntax, core semantics, and verification model. The material is intended to be read as a specification rather than a tutorial.</p>"},{"location":"documentation/#contents","title":"Contents","text":"<ul> <li>int</li> <li>nat</li> <li>func</li> <li>lemma</li> <li>while</li> <li>if/else</li> <li>borrowing</li> <li>update</li> <li>modifies</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>Katon is distributed as a single, cross-platform binary built with Rust. It can be installed using Cargo.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>A recent Rust toolchain</li> <li>Z3 (the SMT solver)</li> </ul>"},{"location":"installation/#install-katon","title":"Install Katon:","text":"<pre><code>cargo install katon\n</code></pre> <p>After installation, the <code>katon</code> binary will be available in your PATH.</p>"},{"location":"semantics/","title":"Semantics of Katon","text":"<p>This page describes the formal semantic model of the Katon Verification Language.</p> <p>Katon does not define execution semantics in the traditional sense. Instead, it defines a verification semantics: how programs are translated into logical formulas and checked by an SMT solver.</p>"},{"location":"semantics/#verification-oriented-semantics","title":"Verification-Oriented Semantics","text":"<p>A Katon program is not executed. It is compiled into verification conditions (VCs) that must be proven valid.</p> <p>Semantics answer the question:</p> <p>Under what logical conditions is this specification satisfied?</p> <p>There is no runtime, no machine state, and no observable behavior. Only logical truth.</p>"},{"location":"semantics/#state-as-logical-variables","title":"State as Logical Variables","text":"<p>Katon models program state as a collection of logical variables.</p> <ul> <li>Each variable represents a value at a specific program point</li> <li>State changes create new logical variables</li> <li>Old values are never mutated or destroyed</li> </ul> <p>State is therefore persistent and immutable at the semantic level.</p>"},{"location":"semantics/#static-single-assignment-ssa","title":"Static Single Assignment (SSA)","text":"<p>All Katon programs are translated into Static Single Assignment (SSA) form.</p> <p>In SSA:</p> <ul> <li>Every variable is assigned exactly once</li> <li>Each assignment introduces a fresh version of that variable</li> </ul> <p>Example:</p> <pre><code>x = 1\nx = x + 1\n</code></pre> <p>Is translated conceptually into:</p> <pre><code>x_0 = 1\nx_1 = x_0 + 1\n</code></pre> <p>This eliminates implicit temporal reasoning. All data dependencies are explicit in the logic.</p>"},{"location":"semantics/#mutation-as-versioning","title":"Mutation as Versioning","text":"<p>What appears as mutation in Katon syntax is version creation semantically.</p> <p>For arrays:</p> <pre><code>arr[0] = 99\n</code></pre> <p>Is translated into:</p> <pre><code>arr_1 = store(arr_0, 0, 99)\n</code></pre> <p>Where:</p> <ul> <li><code>arr_0</code> is the array before the update</li> <li><code>arr_1</code> is the array after the update</li> <li><code>store</code> is the SMT array update function</li> </ul> <p>No array is ever modified in-place.</p>"},{"location":"semantics/#the-meaning-of-old","title":"The Meaning of <code>old</code>","text":"<p>The expression <code>old(e)</code> refers to the value of <code>e</code> in the pre-state of a <code>func</code>.</p> <p>Semantically:</p> <ul> <li>All parameters and mutable variables are given an initial version</li> <li><code>old(x)</code> is resolved to that initial version (<code>x_0</code>)</li> </ul> <p>Example:</p> <pre><code>ensures arr[1] == old(arr)[1]\n</code></pre> <p>Is translated into:</p> <pre><code>select(arr_final, 1) == select(arr_0, 1)\n</code></pre> <p>Because SSA versions are explicit, <code>old</code> is unambiguous and requires no temporal logic.</p>"},{"location":"semantics/#verification-conditions","title":"Verification Conditions","text":"<p>Katon doesn't \"run\" your code to see if it works. Instead, it bundles your entire function\u2014the requirements, the logic, and the goals\u2014into a single massive logical question called a Verification Condition (VC).</p> <p>The question looks like this:</p> \\[Preconditions \u27f9 Postconditions\\] <p>Katon hands this formula to an SMT solver. The solver doesn't look for a way to execute the code; it looks for a counter-example. It asks: \"Is there any possible set of numbers where the '<code>requires</code>' are true, but the '<code>ensures</code>' are false?\" If the solver finds even one such case (like an integer overflow or a boundary error), the program is Invalid.</p> <ul> <li>If the solver proves no such case can ever exist, the program is Verified.</li> </ul>"},{"location":"semantics/#quantifier-free-smt-fragment","title":"Quantifier-Free SMT Fragment","text":"<p>Katon targets a restricted SMT logic:</p> <ul> <li>QF_AUFNIA (quantifier-free arrays, uninterpreted functions, and nonlinear integer arithmetic)</li> </ul> <p>Design consequences:</p> <ul> <li>No user-defined quantifiers</li> <li>No higher-order reasoning</li> <li>No solver hints or tactics</li> </ul> <p>This restriction keeps solver behavior predictable and scalable.</p>"},{"location":"semantics/#totality-and-definedness","title":"Totality and Definedness","text":"<p>All Katon functions are total by construction.</p> <ul> <li>Division by zero</li> <li>Out-of-bounds access</li> <li>Invalid arithmetic</li> </ul> <p>Must be ruled out by preconditions or proven impossible.</p> <p>If definedness cannot be proven automatically, verification fails.</p>"},{"location":"semantics/#absence-of-control-flow-semantics","title":"Absence of Control-Flow Semantics","text":"<p>Katon does not model:</p> <ul> <li>loops as execution constructs</li> <li>recursion as computation</li> <li>branching as control flow</li> </ul> <p>Instead:</p> <ul> <li>conditionals are translated into logical implications</li> <li>invariants are treated as assumptions</li> </ul> <p>There is no notion of step-by-step execution.</p>"},{"location":"semantics/#soundness-boundary","title":"Soundness Boundary","text":"<p>Katon is sound relative to its SMT backend.</p> <p>That is:</p> <ul> <li>If verification succeeds, the specification holds in the SMT model</li> <li>If the solver is unsound, Katon inherits that unsoundness</li> </ul> <p>Katon intentionally avoids features that would widen this boundary.</p>"},{"location":"semantics/#summary","title":"Summary","text":"<p>Katon is not a language for telling a computer what to do. It is a language for telling a solver what must be true. By stripping away the concepts of registers, clocks, and memory, Katon turns programming into a pure exercise in geometry and truth.</p>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2025/12/23/katon-foundations-hoare-logic/","title":"Katon Foundations I: Hoare Logic","text":"<p>Katon is a verification-oriented language. It is not designed to be executed, interpreted, or compiled to machine code. Instead, Katon programs are proved.</p> <p>To make this precise, Katon is founded on Hoare logic \u2014 a classical framework for reasoning about program correctness using logical assertions.</p> <p>Hoare logic answers a simple but fundamental question:</p> <p>Under what conditions does a program satisfy its specification?</p> <p>This question is central to Katon\u2019s design.</p>"},{"location":"blog/2025/12/23/katon-foundations-hoare-logic/#hoare-triples","title":"Hoare Triples","text":"<p>At the heart of Hoare logic is the Hoare triple:</p> \\[ \\{P\\} \\quad C \\quad \\{Q\\} \\] <p>It is read as:</p> <p>If the precondition P holds before executing program C, then the postcondition Q holds after C finishes.</p> <p>In Katon, every function denotes exactly one Hoare triple:</p> \\[ \\{ requires\\} \\quad  body \\quad \\{ ensures\\} \\] <p>A Katon function is verified if its Hoare triple is logically valid.</p>"},{"location":"blog/2025/12/23/katon-foundations-hoare-logic/#katon-functions-as-hoare-triples","title":"Katon Functions as Hoare Triples","text":"<p>Every Katon function corresponds to exactly one Hoare triple.</p> <pre><code>func f(...) \n  requires P\n{\n  body\n}\n  ensures Q\n</code></pre> <p>A Katon function is correct if its Hoare triple is logically valid.</p>"},{"location":"blog/2025/12/23/katon-foundations-hoare-logic/#partial-correctness","title":"Partial Correctness","text":"<p>Katon adopts the notion of partial correctness from Hoare logic.</p> <p>This means:</p> <p>If the function is called in a state satisfying requires, and if it terminates, then ensures holds.</p> <p>Hoare logic separates correctness from termination. This separation keeps the logic simple and compositional.</p>"},{"location":"blog/2025/12/23/katon-foundations-hoare-logic/#what-hoare-logic-does-not-define","title":"What Hoare Logic Does Not Define","text":"<p>Hoare logic intentionally does not define:</p> <ul> <li> <p>execution order</p> </li> <li> <p>runtime behavior</p> </li> <li> <p>performance</p> </li> <li> <p>machine state</p> </li> <li> <p>how values are computed</p> </li> </ul> <p>It only defines logical relationships between states.</p> <p>Katon inherits this philosophy.</p>"},{"location":"blog/2025/12/23/katon-foundations-hoare-logic/#specifications-as-first-class-citizens","title":"Specifications as First-Class Citizens","text":"<p>In Hoare logic, specifications are not comments \u2014 they are mathematical objects.</p> <p>The program exists to justify the specification.</p> <p>In Katon:</p> <ul> <li> <p><code>requires</code> is not a runtime check</p> </li> <li> <p><code>ensures</code> is not documentation</p> </li> <li> <p>the function body is evidence that the specification holds</p> </li> </ul>"},{"location":"blog/2025/12/23/katon-foundations-hoare-logic/#why-katon-chooses-hoare-logic","title":"Why Katon Chooses Hoare Logic","text":"<p>Hoare logic gives Katon:</p> <ul> <li> <p>a small and well-understood foundation</p> </li> <li> <p>compositional reasoning</p> </li> <li> <p>a clear notion of correctness</p> </li> <li> <p>independence from execution models</p> </li> </ul> <p>Most importantly, it lets Katon answer a single, precise question:</p> <p>Is this specification logically satisfied by this program?</p>"},{"location":"documentation/borrowing/","title":"borrowing","text":""},{"location":"documentation/borrowing/#syntax","title":"Syntax","text":"<pre><code>let y = &amp;x;\n</code></pre>"},{"location":"documentation/borrowing/#semantics","title":"Semantics","text":"<p>Borrowing creates a read-only binding to an existing value.</p> <ul> <li><code>y</code> is an alias to the current SSA version of <code>x</code></li> <li>No mutation is permitted through <code>y</code></li> <li><code>x</code> may still be updated or rebound</li> <li><code>y</code> remains bound to the original value</li> </ul> <p>Borrowing restricts names, not data.</p>"},{"location":"documentation/borrowing/#properties","title":"Properties","text":"<ul> <li>Read-only</li> <li>No reassignment</li> <li>No array updates</li> <li>No heap or pointer semantics</li> <li>No lifetime tracking</li> <li>Erased before SMT generation</li> </ul>"},{"location":"documentation/borrowing/#example","title":"Example","text":"<pre><code>let x = [1, 2];\nlet y = &amp;x;\n\nlet x = update(x, 0, 5);\n\nassert y[0] == 1;\nassert x[0] == 5;\n</code></pre>"},{"location":"documentation/borrowing/#forbidden-operations","title":"Forbidden Operations","text":"<pre><code>y = 10;         // error: cannot assign to borrowed variable\ny[0] = 10;      // error: cannot update borrowed variable\n</code></pre>"},{"location":"documentation/borrowing/#notes","title":"Notes","text":"<ul> <li>Borrowing does not copy or move the value</li> <li>Borrowed bindings never consume their source</li> <li>Borrowing introduces no additional SMT variables</li> </ul>"},{"location":"documentation/func/","title":"func","text":"<p>A <code>func</code> defines a callable, executable unit that can returns a value.</p> <p>Functions may have side effects (for example, once mutability is introduced), but their behavior is specified and constrained by contracts. Every <code>func</code> must be verified to satisfy its specification.</p> <p>Each function can include:</p> <ul> <li> <p>Preconditions (<code>requires</code>) that must hold at call time</p> </li> <li> <p>Postconditions (<code>ensures</code>) that must hold on return</p> </li> </ul> <p>The return value is referred to as result inside postconditions.</p> <pre><code>func add_one(x: int) -&gt; int {\n    requires x &lt; 100;\n    ensures result == x + 1;\n\n    return x + 1;\n}\n</code></pre> <p>In this example, the function is only valid for inputs less than <code>100</code>, and the verifier guarantees that the returned value is exactly <code>x + 1</code>. If verification succeeds, the function is emitted as executable code.</p>"},{"location":"documentation/ifelse/","title":"if/else","text":""},{"location":"documentation/ifelse/#syntax","title":"Syntax","text":"<pre><code>if cond {\n    // then-block\n} else {\n    // else-block\n}\n</code></pre>"},{"location":"documentation/ifelse/#semantics","title":"Semantics","text":"<p>The if / else construct evaluates one of two blocks based on a boolean condition.</p> <ul> <li>cond must have type Bool</li> <li>Exactly one branch is executed</li> <li>Both branches are type-checked independently</li> <li>Only variables defined in both branches are visible after the if</li> </ul> <p>Katon uses structural merging of branch environments rather than implicit mutation.</p>"},{"location":"documentation/ifelse/#variable-visibility-and-merging","title":"Variable Visibility and Merging","text":"<p>After an if / else:</p> <ul> <li>A variable is available only if it is defined in both branches</li> <li>The variable must have the same type in both branches</li> <li>Otherwise, the program is rejected</li> </ul> <p>This ensures deterministic SSA and simplifies verification.</p>"},{"location":"documentation/ifelse/#example","title":"Example","text":"<pre><code>if b {\n    let x = 10;\n} else {\n    let x = 20;\n}\n\nassert x == 10 || x == 20;\n</code></pre> <p>Valid because <code>x</code> is defined in both branches with the same type.</p>"},{"location":"documentation/ifelse/#invalid-example","title":"Invalid Example","text":"<pre><code>if b {\n    let x = 10;\n} else {\n    // x not defined\n}\n\nassert x &gt; 0; // error: x not defined in all branches\n</code></pre>"},{"location":"documentation/ifelse/#type-consistency","title":"Type Consistency","text":"<p>If a variable is defined in both branches but with incompatible types, the program is rejected.</p> <pre><code>if b {\n    let x: Int = 1;\n} else {\n    let x: Bool = true;\n}\n// error: type mismatch\n</code></pre>"},{"location":"documentation/ifelse/#borrowing-and-updates-across-branches","title":"Borrowing and Updates Across Branches","text":"<ul> <li>Borrowed variables remain read-only within each branch</li> <li>Functional updates produce branch-local values</li> <li>No mutable aliasing is introduced</li> </ul> <pre><code>let x = [1,2];\n\nif b {\n    let y = &amp;x;\n} else {\n    let y = &amp;x;\n}\n\nassert y[0] == 1;\n</code></pre> <p>Valid: <code>y</code> is borrowed consistently in both branches.</p>"},{"location":"documentation/ifelse/#verification-semantics","title":"Verification Semantics","text":"<ul> <li>Each branch is verified independently</li> <li>Post-condition is checked against the merged environment</li> <li>Control flow introduces no implicit side effects</li> </ul>"},{"location":"documentation/int/","title":"int","text":"<p>The <code>int</code> type denotes mathematical integers in Katon.</p> <p>It is the fundamental numeric type of the language and is used for arithmetic expressions, indexing, counters, and numeric reasoning in specifications.</p> <p><code>int</code> values are unbounded and purely logical. They are not fixed-width and do not model machine integers.</p>"},{"location":"documentation/int/#semantics","title":"Semantics","text":"<p>An <code>int</code> value denotes an element of the mathematical set \u2124.</p> <p>Formally</p> <pre><code>int \u225c \u2124\n</code></pre> <p>All operations on <code>int</code> are interpreted as exact mathematical operations. There is no overflow, underflow, or wrapping behavior.</p> <p>Katon deliberately uses the same <code>int</code> type for both:</p> <ul> <li>executable expressions, and</li> <li>logical specifications (preconditions, postconditions, invariants).</li> </ul> <p>There is no distinction between \u201cruntime integers\u201d and \u201cspecification integers\u201d.</p>"},{"location":"documentation/int/#basic-usage","title":"Basic Usage","text":"<pre><code>let x: int = 10;\nlet y: int = x + 5;\nlet z: int = -y;\n</code></pre> <p>Assignments conceptually create a new logical value; <code>int</code> values themselves are immutable.</p>"},{"location":"documentation/int/#arithmetic-operations","title":"Arithmetic Operations","text":"<p>The following arithmetic operations are defined on <code>int</code>:</p> Operator Meaning + Addition - Subtraction * Multiplication / Integer Division unary - Negation <p>Example:</p> <pre><code>let a: int = 7;\nlet b: int = 3;\n\nlet sum  = a + b;   // 10\nlet diff = a - b;   // 4\nlet prod = a * b;   // 21\n</code></pre>"},{"location":"documentation/int/#copy-semantics","title":"Copy Semantics","text":"<p><code>int</code> is a copy type.</p> <ul> <li>Reading an <code>int</code> does not consume it</li> <li>Assigning or passing an <code>int</code> never invalidates the original value</li> <li>There is no ownership transfer, borrowing, or aliasing</li> </ul> <pre><code>let a: int = 5;\nlet b: int = a;   // always allowed\n</code></pre>"},{"location":"documentation/int/#current-limitations-to-be-fixed","title":"Current Limitations (To Be Fixed)","text":"<p>Warning</p> <p>Some safety properties of <code>int</code> are not fully enforced yet.</p> <ul> <li>Division by zero is not consistently rejected at verification time</li> <li>Some arithmetic safety checks are still being formalized</li> <li>Error messages related to numeric misuse may be incomplete</li> </ul> <p>These limitations are known and temporary. They will be addressed as Katon\u2019s verification condition generation and type system mature.</p>"},{"location":"documentation/lemma/","title":"lemma","text":"<p>A <code>lemma</code> defines ghost code used solely for verification.</p> <p>Lemmas have no runtime representation. They do not produce executable behavior; instead, they establish logical facts for the SMT solver.</p> <p>A lemma may include:</p> <ul> <li> <p>Postconditions (ensures) describing the property being proven</p> </li> <li> <p>An optional body containing proof steps or auxiliary assertions</p> </li> </ul> <p>Unlike <code>func</code>, a <code>lemma</code> does not return a value to the program\u2014its result is a proven fact that can be used during verification.</p> <pre><code>lemma addition_is_commutative(x: int, y: int) {\n    ensures x + y == y + x;\n    // The body may be empty or contain proof steps\n}\n</code></pre> <p>Once verified, a lemma\u2019s <code>ensures</code> clauses become trusted facts that can be reused by the solver, without affecting generated code or runtime behavior.</p>"},{"location":"documentation/let/","title":"let","text":"<p>Katon encourages explicit types in variable declarations. Providing the type up front allows the resolver and type-checker to reason about variables immediately, without relying on inference.</p> <p>The <code>let</code> statement supports three forms:</p> <ul> <li>Uninitialized</li> <li>Initialized</li> <li>Inferred</li> </ul> <pre><code>let x: int;        // Declared but uninitialized (tracked by the borrow checker)\nlet y: nat = 10;   // Declared and initialized\n</code></pre> <p>Uninitialized variables are explicitly tracked by the borrow checker and cannot be used until they are assigned.</p>"},{"location":"documentation/let/#arrays","title":"Arrays","text":"<p>Katon only supports fixed-size arrays. The array size is part of the type, enabling the type-checker to detect out-of-bounds access statically\u2014before the SMT solver is invoked.</p> <pre><code>let arr: [5; int] = [1, 2, 3, 4, 5];\nlet empty: [10; nat]; // Uninitialized array of 10 natural numbers\n</code></pre> <p>Because the size is encoded in the type, array length mismatches and invalid indexing can be rejected early during type checking.</p>"},{"location":"documentation/modifies/","title":"modifies","text":""},{"location":"documentation/modifies/#syntax","title":"Syntax","text":"<pre><code>func f(p1: T1, p2: T2, ...)\n    modifies x1, x2, ...\n{\n    ...\n}\n</code></pre>"},{"location":"documentation/modifies/#semantics","title":"Semantics","text":"<p><code>modifies</code> explicitly declares which variables a function is allowed to update.</p> <p>In Katon, all updates are pure and functional. <code>modifies</code> does not introduce mutation, aliasing, or side effects.</p> <p>Instead, it specifies which variables may receive fresh SSA versions during function execution.</p> <ul> <li> <p>Only variables listed in modifies may be reassigned</p> </li> <li> <p>Variables not listed are framed and must remain unchanged</p> </li> <li> <p>Reassignment always produces a fresh SSA value</p> </li> <li> <p>No variable is mutated in place</p> </li> </ul> <p>Formally, for every variable not listed:</p> <pre><code>x_post = x_pre\n</code></pre>"},{"location":"documentation/modifies/#relation-to-affine-typing","title":"Relation to Affine Typing","text":"<p>Affine types already prevent aliasing. <code>modifies</code> addresses a different concern: framing.</p> <p>It tells the verifier exactly which values may change across a function boundary, allowing precise reasoning without heap havoc or separation logic. Affine typing ensures safety of access; modifies ensures clarity of change.</p>"},{"location":"documentation/modifies/#interaction-with-update","title":"Interaction with Update","text":"<p><code>modifies</code> composes naturally with update.</p> <pre><code>x = update(x, i, v);\n</code></pre> <p><code>update</code> is pure and referentially transparent. It does not consume or mutate its base. Reassigning the result to x is only legal if x appears in modifies. In verification, this becomes an SMT store over a fresh SSA value.</p>"},{"location":"documentation/nat/","title":"nat","text":"<p>The <code>nat</code> type represents natural numbers in Katon.</p> <p>It is a refinement of <code>int</code> used to express values that are known to be non-negative. <code>nat</code> is commonly used for array indices, sizes, counters, and numeric invariants where negativity is invalid by definition.</p>"},{"location":"documentation/nat/#semantics","title":"Semantics","text":"<p>A <code>nat</code> value denotes an element of the mathematical set \u2115.</p> <p>Formally:</p> <pre><code>nat \u225c { n \u2208 \u2124 | n \u2265 0 }\n</code></pre> <p>Semantically, <code>nat</code> is a subset of <code>int</code> with an additional non-negativity constraint. At the logical level, <code>nat</code> values are represented as mathematical integers together with the invariant that their value is greater than or equal to zero.</p>"},{"location":"documentation/nat/#relationship-to-int","title":"Relationship to <code>int</code>","text":"<p><code>nat</code> is not a separate numeric domain from <code>int</code>.</p> <ul> <li>Both <code>int</code> and <code>nat</code> are represented as mathematical integers</li> <li>Every <code>nat</code> is an <code>int</code></li> <li>Not every <code>int</code> is a <code>nat</code></li> </ul> <p>The distinction exists to encode semantic intent and to enable additional verification checks.</p>"},{"location":"documentation/nat/#operations","title":"Operations","text":"<p>All arithmetic and comparison operations defined on <code>int</code> are also defined on <code>nat</code>.</p> Operator Meaning + Addition - Subtraction * Multiplication / Integer Division unary - Negation <p>Operations on <code>nat</code> values produce results of type <code>int</code>. Assigning the result back to a <code>nat</code> variable requires proving that the result is non-negative.</p> <pre><code>let x: nat = 5;\nlet y: int = x - 10;\n</code></pre>"},{"location":"documentation/nat/#assignment-and-safety","title":"Assignment and Safety","text":"<p>Assigning a value to a variable of type <code>nat</code> requires that the value be provably non-negative.</p> <pre><code>let n: nat = 10;        // OK\nlet m: nat = n + 1;     // OK\nlet k: nat = n - 5;     // Requires proof that n \u2265 5\n</code></pre> <p>If the verifier cannot prove that the assigned value is greater than or equal to zero, the program is rejected.</p>"},{"location":"documentation/nat/#copy-semantics","title":"Copy Semantics","text":"<p>Like <code>int</code>, <code>nat</code> is a copy type.</p> <ul> <li> <p>Reading a <code>nat</code> does not consume it</p> </li> <li> <p>Assigning or passing a <code>nat</code> never invalidates the original value</p> </li> <li> <p><code>nat</code> has no ownership, borrowing, or aliasing semantics</p> </li> </ul> <pre><code>let a: nat = 3;\nlet b: nat = a;\n</code></pre>"},{"location":"documentation/nat/#current-limitations-to-be-fixed","title":"Current Limitations (To Be Fixed)","text":"<p>Warning</p> <p>Some safety properties of <code>nat</code> are not fully enforced yet.</p> <ul> <li> <p>Certain arithmetic operations may not generate complete non-negativity proofs</p> </li> <li> <p>Some assignments rely on conservative SMT checks</p> </li> <li> <p>Diagnostic messages for failed <code>nat</code> constraints may be incomplete</p> </li> </ul> <p>These limitations are known and will be addressed as Katon\u2019s verification and type systems mature.</p>"},{"location":"documentation/update/","title":"update","text":""},{"location":"documentation/update/#syntax","title":"Syntax","text":"<pre><code>let x2 = update(x, i, v);\n</code></pre>"},{"location":"documentation/update/#semantics","title":"Semantics","text":"<p><code>update</code> performs a pure functional update on an aggregate value (currently arrays).</p> <ul> <li>Returns a new value</li> <li>Does not mutate <code>x</code></li> <li><code>x</code> remains usable after the update</li> <li>Produces a fresh SSA value</li> <li>Referentially transparent</li> </ul> <p>Formally, for arrays:</p> <pre><code>x2 = store(x, i, v)\n</code></pre>"},{"location":"documentation/update/#properties","title":"Properties","text":"<ul> <li>No aliasing</li> <li>No side effects</li> <li>Safe under verification</li> <li>Composes naturally with SSA</li> <li>Deterministic and total (subject to bounds checking)</li> </ul>"},{"location":"documentation/update/#example","title":"Example","text":"<pre><code>let x = [1, 2, 3];\nlet x2 = update(x, 0, 10);\n\nassert x[0] == 1;\nassert x2[0] == 10;\n</code></pre>"},{"location":"documentation/update/#notes","title":"Notes","text":"<ul> <li><code>update</code> does not consume <code>x</code></li> <li>Index bounds are statically checked when possible</li> <li>Dynamic bounds are discharged to the SMT solver</li> </ul>"},{"location":"documentation/while/","title":"while","text":"<p>Loops are one of the most challenging constructs to verify. For this reason, loop invariants are mandatory for while <code>loops</code> in Katon v0.1.0.</p> <p>A <code>while</code> loop must include one or more <code>invariant</code> clauses that describe properties preserved by every iteration. These invariants are used by the verifier to reason about loop correctness and termination.</p> <pre><code>while i &lt; arr.length() {\n    invariant i &gt;= 0 &amp;&amp; i &lt;= 5;\n    invariant sum &gt;= 0;\n\n    sum = sum + arr[i];\n    i = i + 1;\n}\n</code></pre> <p>In this example, the invariants ensure that the loop index remains within bounds and that <code>sum</code> stays non-negative throughout the loop execution.</p>"},{"location":"blog/archive/2025/","title":"2025","text":""}]}