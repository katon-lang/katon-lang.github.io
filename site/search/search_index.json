{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Katon Verification Language","text":"<p>A small, automated verification language for reasoning about state changes.</p>"},{"location":"#overview","title":"Overview","text":"<p>Katon is a verification-first language designed to answer a single question:</p> <p>Does this state-transforming computation satisfy its specification?</p> <p>It is not a general-purpose programming language. It is a proof-assistant theorem language, in the spirit of Dafny, but deliberately smaller, stricter, and more principled.</p> <p>Katon exists to make reasoning about mutable state tractable, predictable, and fully automated.</p>"},{"location":"#what-makes-katon-different","title":"What Makes Katon Different","text":"<p>Katon is built around a small number of non-negotiable ideas:</p> <ul> <li> <p>Verification, not execution   Katon programs describe state transitions, not runtime behavior.</p> </li> <li> <p>Ownership eliminates aliasing   Rust-style move semantics remove aliasing at the language level,   dramatically simplifying reasoning.</p> </li> <li> <p>Automation over interaction   All proof obligations are discharged by SMT solvers.   There are no tactics, scripts, or interactive proofs.</p> </li> <li> <p>Small types, strong guarantees   A minimal type system keeps verification decidable and solver-friendly.</p> </li> </ul> <p>These constraints are not limitations. They are what make Katon precise.</p>"},{"location":"#a-glimpse-of-katon","title":"A Glimpse of Katon","text":"<p>A Katon <code>func</code> specifies how state may change and what must hold afterward:</p> <pre><code>func update(arr [int]) {\n    arr[0] = 99\n    ensures arr[0] == 99\n    ensures arr[1] == old(arr)[1]\n}\n</code></pre>"},{"location":"#what-katon-is-not","title":"What Katon Is Not","text":"<p>Katon intentionally excludes features that increase proof complexity:</p> <ul> <li> <p>no general recursion</p> </li> <li> <p>no heap allocation</p> </li> <li> <p>no higher-order functions</p> </li> <li> <p>no interactive proving</p> </li> </ul> <p>Every omission is deliberate. Every omission keeps reasoning simple.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Katon is still in an early stage of development.</p> <p>If you are interested in formal verification, programming languages, or compiler construction\u2014or if you are working on a programming languages assignment\u2014you are welcome to try Katon and contribute.</p>"},{"location":"contributing/#ways-to-contribute","title":"Ways to Contribute","text":"<p>Contributions of all kinds are appreciated, including:</p> <ol> <li> <p>Bug reports: report incorrect behavior, crashes, or unsound verification results.</p> </li> <li> <p>Documentation improvements: clarify existing documentation, fix inaccuracies, or add missing language reference sections.</p> </li> <li> <p>Language and verifier development: work on the type system, semantics, verification condition generation, or SMT integration.</p> </li> <li> <p>Design discussions: propose or discuss language features, semantics, or design trade-offs.</p> </li> </ol>"},{"location":"contributing/#contribution-process","title":"Contribution Process","text":"<ol> <li> <p>Use GitHub Issues for bug reports, feature requests, and design discussions.</p> </li> <li> <p>Submit changes via pull requests.</p> </li> <li> <p>Small, focused pull requests are preferred.</p> </li> </ol> <p>For non-trivial changes, opening an issue for discussion first is recommended.</p>"},{"location":"contributing/#repository","title":"Repository","text":"<p>Katon on GitHub</p>"},{"location":"documentation/","title":"Overview","text":"<p>This section contains the technical documentation for the Katon language.</p> <p>It serves as the language reference, describing Katon\u2019s syntax, core semantics, and verification model. The material is intended to be read as a specification rather than a tutorial.</p>"},{"location":"documentation/#contents","title":"Contents","text":"<ul> <li>int</li> <li>nat</li> <li>func</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>Katon is distributed as a single, cross-platform binary built with Rust. It can be installed using Cargo.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>A recent Rust toolchain</li> <li>Z3 (the SMT solver)</li> </ul>"},{"location":"installation/#install-katon","title":"Install Katon:","text":"<pre><code>cargo install katon\n</code></pre> <p>After installation, the <code>katon</code> binary will be available in your PATH.</p>"},{"location":"semantics/","title":"Semantics of Katon","text":"<p>This page describes the formal semantic model of the Katon Verification Language.</p> <p>Katon does not define execution semantics in the traditional sense. Instead, it defines a verification semantics: how programs are translated into logical formulas and checked by an SMT solver.</p>"},{"location":"semantics/#verification-oriented-semantics","title":"Verification-Oriented Semantics","text":"<p>A Katon program is not executed. It is compiled into verification conditions (VCs) that must be proven valid.</p> <p>Semantics answer the question:</p> <p>Under what logical conditions is this specification satisfied?</p> <p>There is no runtime, no machine state, and no observable behavior. Only logical truth.</p>"},{"location":"semantics/#state-as-logical-variables","title":"State as Logical Variables","text":"<p>Katon models program state as a collection of logical variables.</p> <ul> <li>Each variable represents a value at a specific program point</li> <li>State changes create new logical variables</li> <li>Old values are never mutated or destroyed</li> </ul> <p>State is therefore persistent and immutable at the semantic level.</p>"},{"location":"semantics/#static-single-assignment-ssa","title":"Static Single Assignment (SSA)","text":"<p>All Katon programs are translated into Static Single Assignment (SSA) form.</p> <p>In SSA:</p> <ul> <li>Every variable is assigned exactly once</li> <li>Each assignment introduces a fresh version of that variable</li> </ul> <p>Example:</p> <pre><code>x = 1\nx = x + 1\n</code></pre> <p>Is translated conceptually into:</p> <pre><code>x_0 = 1\nx_1 = x_0 + 1\n</code></pre> <p>This eliminates implicit temporal reasoning. All data dependencies are explicit in the logic.</p>"},{"location":"semantics/#mutation-as-versioning","title":"Mutation as Versioning","text":"<p>What appears as mutation in Katon syntax is version creation semantically.</p> <p>For arrays:</p> <pre><code>arr[0] = 99\n</code></pre> <p>Is translated into:</p> <pre><code>arr_1 = store(arr_0, 0, 99)\n</code></pre> <p>Where:</p> <ul> <li><code>arr_0</code> is the array before the update</li> <li><code>arr_1</code> is the array after the update</li> <li><code>store</code> is the SMT array update function</li> </ul> <p>No array is ever modified in-place.</p>"},{"location":"semantics/#the-meaning-of-old","title":"The Meaning of <code>old</code>","text":"<p>The expression <code>old(e)</code> refers to the value of <code>e</code> in the pre-state of a <code>func</code>.</p> <p>Semantically:</p> <ul> <li>All parameters and mutable variables are given an initial version</li> <li><code>old(x)</code> is resolved to that initial version (<code>x_0</code>)</li> </ul> <p>Example:</p> <pre><code>ensures arr[1] == old(arr)[1]\n</code></pre> <p>Is translated into:</p> <pre><code>select(arr_final, 1) == select(arr_0, 1)\n</code></pre> <p>Because SSA versions are explicit, <code>old</code> is unambiguous and requires no temporal logic.</p>"},{"location":"semantics/#verification-conditions","title":"Verification Conditions","text":"<p>Katon doesn't \"run\" your code to see if it works. Instead, it bundles your entire function\u2014the requirements, the logic, and the goals\u2014into a single massive logical question called a Verification Condition (VC).</p> <p>The question looks like this:</p> \\[Preconditions \u27f9 Postconditions\\] <p>Katon hands this formula to an SMT solver. The solver doesn't look for a way to execute the code; it looks for a counter-example. It asks: \"Is there any possible set of numbers where the '<code>requires</code>' are true, but the '<code>ensures</code>' are false?\" If the solver finds even one such case (like an integer overflow or a boundary error), the program is Invalid.</p> <ul> <li>If the solver proves no such case can ever exist, the program is Verified.</li> </ul>"},{"location":"semantics/#quantifier-free-smt-fragment","title":"Quantifier-Free SMT Fragment","text":"<p>Katon targets a restricted SMT logic:</p> <ul> <li>QF_AUFNIA (quantifier-free arrays, uninterpreted functions, and nonlinear integer arithmetic)</li> </ul> <p>Design consequences:</p> <ul> <li>No user-defined quantifiers</li> <li>No higher-order reasoning</li> <li>No solver hints or tactics</li> </ul> <p>This restriction keeps solver behavior predictable and scalable.</p>"},{"location":"semantics/#totality-and-definedness","title":"Totality and Definedness","text":"<p>All Katon functions are total by construction.</p> <ul> <li>Division by zero</li> <li>Out-of-bounds access</li> <li>Invalid arithmetic</li> </ul> <p>Must be ruled out by preconditions or proven impossible.</p> <p>If definedness cannot be proven automatically, verification fails.</p>"},{"location":"semantics/#absence-of-control-flow-semantics","title":"Absence of Control-Flow Semantics","text":"<p>Katon does not model:</p> <ul> <li>loops as execution constructs</li> <li>recursion as computation</li> <li>branching as control flow</li> </ul> <p>Instead:</p> <ul> <li>conditionals are translated into logical implications</li> <li>invariants are treated as assumptions</li> </ul> <p>There is no notion of step-by-step execution.</p>"},{"location":"semantics/#soundness-boundary","title":"Soundness Boundary","text":"<p>Katon is sound relative to its SMT backend.</p> <p>That is:</p> <ul> <li>If verification succeeds, the specification holds in the SMT model</li> <li>If the solver is unsound, Katon inherits that unsoundness</li> </ul> <p>Katon intentionally avoids features that would widen this boundary.</p>"},{"location":"semantics/#summary","title":"Summary","text":"<p>Katon is not a language for telling a computer what to do. It is a language for telling a solver what must be true. By stripping away the concepts of registers, clocks, and memory, Katon turns programming into a pure exercise in geometry and truth.</p>"},{"location":"documentation/func/","title":"func","text":"<p>COMING SOON</p>"},{"location":"documentation/int/","title":"int","text":"<p>The <code>int</code> type denotes mathematical integers in Katon.</p> <p>It is the fundamental numeric type of the language and is used for arithmetic expressions, indexing, counters, and numeric reasoning in specifications.</p> <p><code>int</code> values are unbounded and purely logical. They are not fixed-width and do not model machine integers.</p>"},{"location":"documentation/int/#semantics","title":"Semantics","text":"<p>An <code>int</code> value denotes an element of the mathematical set \u2124.</p> <p>Formally</p> <pre><code>int \u225c \u2124\n</code></pre> <p>All operations on <code>int</code> are interpreted as exact mathematical operations. There is no overflow, underflow, or wrapping behavior.</p> <p>Katon deliberately uses the same <code>int</code> type for both:</p> <ul> <li>executable expressions, and</li> <li>logical specifications (preconditions, postconditions, invariants).</li> </ul> <p>There is no distinction between \u201cruntime integers\u201d and \u201cspecification integers\u201d.</p>"},{"location":"documentation/int/#basic-usage","title":"Basic Usage","text":"<pre><code>let x: int = 10;\nlet y: int = x + 5;\nlet z: int = -y;\n</code></pre> <p>Assignments conceptually create a new logical value; <code>int</code> values themselves are immutable.</p>"},{"location":"documentation/int/#arithmetic-operations","title":"Arithmetic Operations","text":"<p>The following arithmetic operations are defined on <code>int</code>:</p> Operator Meaning + Addition - Subtraction * Multiplication / Integer Division unary - Negation <p>Example:</p> <pre><code>let a: int = 7;\nlet b: int = 3;\n\nlet sum  = a + b;   // 10\nlet diff = a - b;   // 4\nlet prod = a * b;   // 21\n</code></pre>"},{"location":"documentation/int/#copy-semantics","title":"Copy Semantics","text":"<p><code>int</code> is a copy type.</p> <ul> <li>Reading an <code>int</code> does not consume it</li> <li>Assigning or passing an <code>int</code> never invalidates the original value</li> <li>There is no ownership transfer, borrowing, or aliasing</li> </ul> <pre><code>let a: int = 5;\nlet b: int = a;   // always allowed\n</code></pre>"},{"location":"documentation/int/#current-limitations-to-be-fixed","title":"Current Limitations (To Be Fixed)","text":"<p>Warning</p> <p>Some safety properties of <code>int</code> are not fully enforced yet.</p> <ul> <li>Division by zero is not consistently rejected at verification time</li> <li>Some arithmetic safety checks are still being formalized</li> <li>Error messages related to numeric misuse may be incomplete</li> </ul> <p>These limitations are known and temporary. They will be addressed as Katon\u2019s verification condition generation and type system mature.</p>"},{"location":"documentation/nat/","title":"nat","text":"<p>The <code>nat</code> type represents natural numbers in Katon.</p> <p>It is a refinement of <code>int</code> used to express values that are known to be non-negative. <code>nat</code> is commonly used for array indices, sizes, counters, and numeric invariants where negativity is invalid by definition.</p>"},{"location":"documentation/nat/#semantics","title":"Semantics","text":"<p>A <code>nat</code> value denotes an element of the mathematical set \u2115.</p> <p>Formally:</p> <pre><code>nat \u225c { n \u2208 \u2124 | n \u2265 0 }\n</code></pre> <p>Semantically, <code>nat</code> is a subset of <code>int</code> with an additional non-negativity constraint. At the logical level, <code>nat</code> values are represented as mathematical integers together with the invariant that their value is greater than or equal to zero.</p>"},{"location":"documentation/nat/#relationship-to-int","title":"Relationship to <code>int</code>","text":"<p><code>nat</code> is not a separate numeric domain from <code>int</code>.</p> <ul> <li>Both <code>int</code> and <code>nat</code> are represented as mathematical integers</li> <li>Every <code>nat</code> is an <code>int</code></li> <li>Not every <code>int</code> is a <code>nat</code></li> </ul> <p>The distinction exists to encode semantic intent and to enable additional verification checks.</p>"},{"location":"documentation/nat/#operations","title":"Operations","text":"<p>All arithmetic and comparison operations defined on <code>int</code> are also defined on <code>nat</code>.</p> Operator Meaning + Addition - Subtraction * Multiplication / Integer Division unary - Negation <p>Operations on <code>nat</code> values produce results of type <code>int</code>. Assigning the result back to a <code>nat</code> variable requires proving that the result is non-negative.</p> <pre><code>let x: nat = 5;\nlet y: int = x - 10;\n</code></pre>"},{"location":"documentation/nat/#assignment-and-safety","title":"Assignment and Safety","text":"<p>Assigning a value to a variable of type <code>nat</code> requires that the value be provably non-negative.</p> <pre><code>let n: nat = 10;        // OK\nlet m: nat = n + 1;     // OK\nlet k: nat = n - 5;     // Requires proof that n \u2265 5\n</code></pre> <p>If the verifier cannot prove that the assigned value is greater than or equal to zero, the program is rejected.</p>"},{"location":"documentation/nat/#copy-semantics","title":"Copy Semantics","text":"<p>Like <code>int</code>, <code>nat</code> is a copy type.</p> <ul> <li> <p>Reading a <code>nat</code> does not consume it</p> </li> <li> <p>Assigning or passing a <code>nat</code> never invalidates the original value</p> </li> <li> <p><code>nat</code> has no ownership, borrowing, or aliasing semantics</p> </li> </ul> <pre><code>let a: nat = 3;\nlet b: nat = a;\n</code></pre>"},{"location":"documentation/nat/#current-limitations-to-be-fixed","title":"Current Limitations (To Be Fixed)","text":"<p>Warning</p> <p>Some safety properties of <code>nat</code> are not fully enforced yet.</p> <ul> <li> <p>Certain arithmetic operations may not generate complete non-negativity proofs</p> </li> <li> <p>Some assignments rely on conservative SMT checks</p> </li> <li> <p>Diagnostic messages for failed <code>nat</code> constraints may be incomplete</p> </li> </ul> <p>These limitations are known and will be addressed as Katon\u2019s verification and type systems mature.</p>"}]}