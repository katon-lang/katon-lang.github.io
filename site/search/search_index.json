{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Katon Verification Language","text":"<p>A small, automated verification language for reasoning about state changes.</p>"},{"location":"#overview","title":"Overview","text":"<p>Katon is a verification-first language designed to answer a single question:</p> <p>Does this state-transforming computation satisfy its specification?</p> <p>It is not a general-purpose programming language. It is a proof-assistant theorem language, in the spirit of Dafny, but deliberately smaller, stricter, and more principled.</p> <p>Katon exists to make reasoning about mutable state tractable, predictable, and fully automated.</p>"},{"location":"#what-makes-katon-different","title":"What Makes Katon Different","text":"<p>Katon is built around a small number of non-negotiable ideas:</p> <ul> <li> <p>Verification, not execution   Katon programs describe state transitions, not runtime behavior.</p> </li> <li> <p>Ownership eliminates aliasing   Rust-style move semantics remove aliasing at the language level,   dramatically simplifying reasoning.</p> </li> <li> <p>Automation over interaction   All proof obligations are discharged by SMT solvers.   There are no tactics, scripts, or interactive proofs.</p> </li> <li> <p>Small types, strong guarantees   A minimal type system keeps verification decidable and solver-friendly.</p> </li> </ul> <p>These constraints are not limitations. They are what make Katon precise.</p>"},{"location":"#a-glimpse-of-katon","title":"A Glimpse of Katon","text":"<p>A Katon <code>func</code> specifies how state may change and what must hold afterward:</p> <pre><code>func update(arr [int]) {\n    arr[0] = 99\n    ensures arr[0] == 99\n    ensures arr[1] == old(arr)[1]\n}\n</code></pre>"},{"location":"#what-katon-is-not","title":"What Katon Is Not","text":"<p>Katon intentionally excludes features that increase proof complexity:</p> <ul> <li> <p>no general recursion</p> </li> <li> <p>no heap allocation</p> </li> <li> <p>no higher-order functions</p> </li> <li> <p>no interactive proving</p> </li> </ul> <p>Every omission is deliberate. Every omission keeps reasoning simple.</p>"},{"location":"documentation/","title":"Documentation","text":"<p>Consist of Katon technical documentation, syntax, and the manual.</p> <p>COMING SOON!</p>"},{"location":"semantics/","title":"Semantics of Katon","text":"<p>This page describes the formal semantic model of the Katon Verification Language.</p> <p>Katon does not define execution semantics in the traditional sense. Instead, it defines a verification semantics: how programs are translated into logical formulas and checked by an SMT solver.</p>"},{"location":"semantics/#verification-oriented-semantics","title":"Verification-Oriented Semantics","text":"<p>A Katon program is not executed. It is compiled into verification conditions (VCs) that must be proven valid.</p> <p>Semantics answer the question:</p> <p>Under what logical conditions is this specification satisfied?</p> <p>There is no runtime, no machine state, and no observable behavior. Only logical truth.</p>"},{"location":"semantics/#state-as-logical-variables","title":"State as Logical Variables","text":"<p>Katon models program state as a collection of logical variables.</p> <ul> <li>Each variable represents a value at a specific program point</li> <li>State changes create new logical variables</li> <li>Old values are never mutated or destroyed</li> </ul> <p>State is therefore persistent and immutable at the semantic level.</p>"},{"location":"semantics/#static-single-assignment-ssa","title":"Static Single Assignment (SSA)","text":"<p>All Katon programs are translated into Static Single Assignment (SSA) form.</p> <p>In SSA:</p> <ul> <li>Every variable is assigned exactly once</li> <li>Each assignment introduces a fresh version of that variable</li> </ul> <p>Example:</p> <pre><code>x = 1\nx = x + 1\n</code></pre> <p>Is translated conceptually into:</p> <pre><code>x_0 = 1\nx_1 = x_0 + 1\n</code></pre> <p>This eliminates implicit temporal reasoning. All data dependencies are explicit in the logic.</p>"},{"location":"semantics/#mutation-as-versioning","title":"Mutation as Versioning","text":"<p>What appears as mutation in Katon syntax is version creation semantically.</p> <p>For arrays:</p> <pre><code>arr[0] = 99\n</code></pre> <p>Is translated into:</p> <pre><code>arr_1 = store(arr_0, 0, 99)\n</code></pre> <p>Where:</p> <ul> <li><code>arr_0</code> is the array before the update</li> <li><code>arr_1</code> is the array after the update</li> <li><code>store</code> is the SMT array update function</li> </ul> <p>No array is ever modified in-place.</p>"},{"location":"semantics/#the-meaning-of-old","title":"The Meaning of <code>old</code>","text":"<p>The expression <code>old(e)</code> refers to the value of <code>e</code> in the pre-state of a <code>func</code>.</p> <p>Semantically:</p> <ul> <li>All parameters and mutable variables are given an initial version</li> <li><code>old(x)</code> is resolved to that initial version (<code>x_0</code>)</li> </ul> <p>Example:</p> <pre><code>ensures arr[1] == old(arr)[1]\n</code></pre> <p>Is translated into:</p> <pre><code>select(arr_final, 1) == select(arr_0, 1)\n</code></pre> <p>Because SSA versions are explicit, <code>old</code> is unambiguous and requires no temporal logic.</p>"},{"location":"semantics/#verification-conditions","title":"Verification Conditions","text":"<p>Katon doesn't \"run\" your code to see if it works. Instead, it bundles your entire function\u2014the requirements, the logic, and the goals\u2014into a single massive logical question called a Verification Condition (VC).</p> <p>The question looks like this:</p> \\[Preconditions \u27f9 Postconditions\\] <p>Katon hands this formula to an SMT solver. The solver doesn't look for a way to execute the code; it looks for a counter-example. It asks: \"Is there any possible set of numbers where the '<code>requires</code>' are true, but the '<code>ensures</code>' are false?\" If the solver finds even one such case (like an integer overflow or a boundary error), the program is Invalid.</p> <ul> <li>If the solver proves no such case can ever exist, the program is Verified.</li> </ul>"},{"location":"semantics/#quantifier-free-smt-fragment","title":"Quantifier-Free SMT Fragment","text":"<p>Katon targets a restricted SMT logic:</p> <ul> <li>QF_AUFNIA (quantifier-free arrays, uninterpreted functions, and nonlinear integer arithmetic)</li> </ul> <p>Design consequences:</p> <ul> <li>No user-defined quantifiers</li> <li>No higher-order reasoning</li> <li>No solver hints or tactics</li> </ul> <p>This restriction keeps solver behavior predictable and scalable.</p>"},{"location":"semantics/#totality-and-definedness","title":"Totality and Definedness","text":"<p>All Katon functions are total by construction.</p> <ul> <li>Division by zero</li> <li>Out-of-bounds access</li> <li>Invalid arithmetic</li> </ul> <p>Must be ruled out by preconditions or proven impossible.</p> <p>If definedness cannot be proven automatically, verification fails.</p>"},{"location":"semantics/#absence-of-control-flow-semantics","title":"Absence of Control-Flow Semantics","text":"<p>Katon does not model:</p> <ul> <li>loops as execution constructs</li> <li>recursion as computation</li> <li>branching as control flow</li> </ul> <p>Instead:</p> <ul> <li>conditionals are translated into logical implications</li> <li>invariants are treated as assumptions</li> </ul> <p>There is no notion of step-by-step execution.</p>"},{"location":"semantics/#soundness-boundary","title":"Soundness Boundary","text":"<p>Katon is sound relative to its SMT backend.</p> <p>That is:</p> <ul> <li>If verification succeeds, the specification holds in the SMT model</li> <li>If the solver is unsound, Katon inherits that unsoundness</li> </ul> <p>Katon intentionally avoids features that would widen this boundary.</p>"},{"location":"semantics/#summary","title":"Summary","text":"<p>Katon is not a language for telling a computer what to do. It is a language for telling a solver what must be true. By stripping away the concepts of registers, clocks, and memory, Katon turns programming into a pure exercise in geometry and truth.</p>"}]}